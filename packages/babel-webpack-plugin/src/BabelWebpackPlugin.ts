import webpack from 'webpack'
import JsonpTemplatePlugin from 'webpack/lib/web/JsonpTemplatePlugin'
import SplitChunksPlugin from 'webpack/lib/optimize/SplitChunksPlugin'
import RuntimeChunkPlugin from 'webpack/lib/optimize/RuntimeChunkPlugin'
import RawModule from 'webpack/lib/RawModule'
import EntryConfigPlugin from './EntryConfigPlugin'

const PLUGIN_NAME = 'babel-webpack-plugin'

interface PublicTargetOptions extends webpack.Output {
  target: string
  excludedPlugins?: webpack.Plugin[] | null
  additionalPlugins?: webpack.Plugin[] | null
}
interface PublicOptions {
  targets: PublicTargetOptions[]
}

interface PrivateTargetOptions extends webpack.Output {
  target: string
  excludedPlugins: webpack.Plugin[]
  additionalPlugins: webpack.Plugin[]
}
interface PrivateOptions {
  targets: PrivateTargetOptions[]
}

/**
 * Adopted from
 * https://github.com/styleguidist/mini-html-webpack-plugin
 * https://github.com/rasmuskl/simple-html-webpack-plugin
 * https://github.com/zaaack/htmls-webpack-plugin
 */
class BabelWebpackPlugin implements webpack.Plugin {
  // extend causes cyclic dependencies
  private readonly options: PrivateOptions
  public static readonly loader = require.resolve('./babel-loader.js')

  public constructor(options: PublicOptions) {
    const targets = options.targets.map(option => {
      const newOptions: PrivateTargetOptions = {
        ...option,
        excludedPlugins: option.excludedPlugins || [],
        additionalPlugins: option.additionalPlugins || [],
      }
      newOptions.excludedPlugins.push(BabelWebpackPlugin)
      return newOptions
    })
    this.options = { targets }
    this.compilerMakeHook = this.compilerMakeHook.bind(this)
  }

  /**
   * Entrypoint that webpack calls at the start.
   *
   * @param compiler webpack.Compiler
   */
  public apply(compiler: webpack.Compiler): void {
    compiler.hooks.make.tap(PLUGIN_NAME, compilation => {
      this.compilerMakeHook(compiler, compilation)
    })
  }

  /**
   * Entrypoint that webpack calls during the `make` phase.
   * see: https://webpack.js.org/api/compiler-hooks/#make
   *
   * @param compiler webpack.Compiler
   * @param compilation webpack.compilation.Compilation
   */
  private compilerMakeHook(
    compiler: webpack.Compiler,
    compilation: webpack.compilation.Compilation,
  ) {
    const [primaryTarget, ...additionalTargets] = this.options.targets

    const childCompilerOutputs: Promise<{
      entries: webpack.Entry[]
      childCompilation: webpack.compilation.Compilation
    }>[] = additionalTargets.map(options =>
      BabelWebpackPlugin.runChildCompiler(compiler, compilation, options),
    )

    /**
     * Inject the `target` option to our existing loader so that they can run
     * with the specified target.
     * Additional targets are passed to childCompilations to process.
     * see: https://webpack.js.org/api/compilation-hooks/#normalmoduleloader
     * note: deprecated in webpack 5
     */
    compilation.hooks.normalModuleLoader.tap(PLUGIN_NAME, (context, module) => {
      // @ts-ignore property loaders does exist but is not typed
      const newLoaders = module.loaders as webpack.NewLoader[]
      for (let i = 0; i < newLoaders.length; i++) {
        const newLoader = newLoaders[i]
        if (newLoader.loader !== BabelWebpackPlugin.loader) return
        newLoader.options = {
          ...newLoader.options,
          target: primaryTarget.target,
        }
      }
    })

    /**
     * Adds all the additional files generated by different targets into the
     * main parent chunks.
     * see: https://webpack.js.org/api/compilation-hooks/#additionalassets
     */
    compilation.hooks.additionalAssets.tapPromise(PLUGIN_NAME, () => {
      const parentChunkByName: { [key: string]: webpack.compilation.Chunk } = {}
      for (const chunk of compilation.chunks) {
        parentChunkByName[chunk.name] = chunk
      }

      return Promise.all(childCompilerOutputs)
        .then(childCompilerOutputs => {
          for (const { childCompilation } of childCompilerOutputs) {
            for (const chunk of childCompilation.chunks as webpack.compilation.Chunk[]) {
              const parentChunk = parentChunkByName[chunk.name]
              if (!parentChunk) return
              parentChunk.files.push(...chunk.files)
            }

            const assetKeys = Object.keys(childCompilation.assets)
            for (let i = 0; i < assetKeys.length; i++) {
              const key = assetKeys[i]
              compilation.assets[key] = childCompilation.assets[key]
            }
            childCompilation.assets = {}
            for (const [key, value] of childCompilation.namedChunkGroups) {
              compilation.namedChunkGroups.set(key, value)
            }
            childCompilation.namedChunkGroups.clear()
          }
        })
        .catch(error => {
          compilation.errors.push(error)
        })
    })
  }

  /**
   * Runs a child compiler that returns output of the entry,
   * which in this case, is the same compilation but with a different target.
   *
   * @param compiler webpack.Compiler
   * @param compilation webpack.compilation.Compilation
   * @param targetOptions PrivateTargetOptions
   * @returns Promise<entries, childCompilation>
   */
  private static runChildCompiler(
    compiler: webpack.Compiler,
    compilation: webpack.compilation.Compilation,
    targetOptions: PrivateTargetOptions,
  ): Promise<{
    entries: webpack.Entry[]
    childCompilation: webpack.compilation.Compilation
  }> {
    const {
      target,
      excludedPlugins,
      additionalPlugins,
      ...targetOutputOptions
    } = targetOptions

    const outputOptions = {
      ...compiler.options.output,
      ...targetOutputOptions,
    }
    /**
     * We do not passing plugins in createChildCompiler until additional options
     * has been added, such as file systems and loader modifications.
     * Since all webpack does with plugins is call the `apply` method on them,
     * we can do that ourselves later.
     */
    const childCompiler = compilation.createChildCompiler(
      PLUGIN_NAME,
      outputOptions,
      [],
    )
    childCompiler.context = compiler.context
    childCompiler.inputFileSystem = compiler.inputFileSystem
    childCompiler.outputFileSystem = compiler.outputFileSystem

    /**
     * Ignore every file that does not have our loader, so we do not
     * perform extra webpack compilations.
     * see: https://webpack.js.org/api/compiler-hooks/#normalmodulefactory
     */
    childCompiler.hooks.normalModuleFactory.tap(PLUGIN_NAME, nmf => {
      // TODO: webpack v5 bail out in afterResolve hook instead
      nmf.hooks.createModule.tap(PLUGIN_NAME, module => {
        // @ts-ignore property loaders does exist but is not typed
        const newLoaders = module.loaders as webpack.NewLoader[]
        const ownLoader = BabelWebpackPlugin.loader
        if (newLoaders.some(newLoader => newLoader.loader === ownLoader)) return

        const { context, request, rawRequest } = module
        return new RawModule(
          '/* (ignored) */',
          `ignored ${context} ${request}`,
          `${rawRequest} (ignored)`,
        )
      })
    })

    /**
     * Inject the `target` option to our loader so that they can run
     * with the specified target.
     * see: https://webpack.js.org/api/compiler-hooks/#compilation
     */
    childCompiler.hooks.compilation.tap(PLUGIN_NAME, compilation => {
      /**
       * see: https://webpack.js.org/api/compilation-hooks/#normalmoduleloader
       * note: deprecated in webpack 5
       */
      compilation.hooks.normalModuleLoader.tap(
        PLUGIN_NAME,
        (context, module) => {
          // @ts-ignore property loaders does exist but is not typed
          const newLoaders = module.loaders as webpack.NewLoader[]
          for (let i = 0; i < newLoaders.length; i++) {
            const newLoader = newLoaders[i]
            if (newLoader.loader !== BabelWebpackPlugin.loader) return
            newLoader.options = { ...newLoader.options, target }
          }
        },
      )
    })

    /**
     * Apply the plugins as mentioned earlier.
     * Includes various performance related plugins that webpack uses
     * natively.
     */
    const plugins = compiler.options.plugins || []
    for (const plugin of plugins) {
      const isIncluded = !excludedPlugins.some(
        // @ts-ignore webpack.Plugin is extended and not implemented
        excludedPlugin => plugin instanceof excludedPlugin,
      )
      if (isIncluded) {
        plugin.apply(childCompiler)
      }
    }
    for (const plugin of additionalPlugins) {
      plugin.apply(childCompiler)
    }

    new EntryConfigPlugin(compiler.context, compiler.options.entry).apply(
      childCompiler,
    )

    // Convert entry chunk to entry file
    new JsonpTemplatePlugin().apply(childCompiler)

    if (compiler.options.optimization) {
      if (compiler.options.optimization.splitChunks) {
        new SplitChunksPlugin(
          Object.assign({}, compiler.options.optimization.splitChunks),
        ).apply(childCompiler)
      }
      if (compiler.options.optimization.runtimeChunk) {
        new RuntimeChunkPlugin(
          Object.assign({}, compiler.options.optimization.runtimeChunk),
        ).apply(childCompiler)
      }
    }

    // Return child compilation execution as a promise
    return new Promise((resolve, reject) => {
      childCompiler.runAsChild((err, entries, childCompilation) => {
        if (err) {
          reject(err)
          return
        }
        resolve({
          entries,
          childCompilation,
        })
      })
    })
  }
}

export default BabelWebpackPlugin
